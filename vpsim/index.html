<!DOCTYPE html>
<meta charset=UTF-8>
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LAH VPシミュレータ（β）">
<meta name=viewport content="width=device-width,maximum-scale=1">
<meta name=theme-color content="#400">
<link rel=stylesheet href="/theme/theme.css">
<script src="/theme/theme.js"></script>
<style>
* {
  margin: 0;
  padding: 0;
  font-family: "Courier", monospace;
  font-size: small;
  box-sizing: border-box;
}
fieldset {
  margin: 1rem;
  padding: 0.5rem;
  border-radius: 0.5rem;
}
.panel {
  margin: 0.2rem;
  border: 1px solid black;
  border-radius: 0.5rem;
  background-color: #8884;
}
.titlebar {
  display: flex;
  padding: 0.2rem;
  padding-left: 0.8rem;
  border-radius: 0.5rem 0.5rem 0 0;
  background-color: #6663;
  justify-content: space-between;
  align-items: center;
}
.panel:first-of-type .upbutton {
  visibility: hidden;
}
.content {
  padding: 0.5rem;
}
input[type="number"] {
  padding: revert;
  margin: 0 0.5rem;
  text-align: right;
  width: 5rem;
}
input[list]::-webkit-list-button {
  order: -1;
}
input[type="number"].lv {
  width: 3rem;
}
input[type="button"] {
  padding: revert;
}
.appendpanel input {
  height: 2.2rem;
  width: 2.2rem;
  border-radius: 1.1rem;
}
input[type="checkbox"] {
  margin: 0 0.4rem;
}
button {
  appearance: none;
  margin: 0 0.4rem;
  border: none;
  background-color: transparent;
  font-size: medium;
}
.hidecolor input[type="color"] {
  width: 0;
  height: 0;
  appearance: none;
}
.colorlabel {
  margin-right: 1rem;
}
label {
  display: inline-block;
}
hr {
  margin: 0.5rem 0.2rem;
}
.grid {
  display: grid;
  grid-template-columns: auto auto auto 1fr;
  gap: 0.4rem;
}
.grid label {
  align-items: center;
}
.grid label.number {
  display: grid;
  grid-template-columns: subgrid;
  gap: 0;
  grid-column: 1 / 3;
}
#timeline .grid label.number {
  grid-column: span 2;
}
.grid label.checkbox {
  grid-column: 3 / 5;
}
.header {
  margin-top: 0.3rem;
  padding: 0.2rem;
}
.footer {
  text-align: right;
  padding: 0.3rem;
  margin-bottom: 0.4rem;
}
#timeline .footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
output {
  margin: 0.5rem;
}
.footer output {
  font-size: medium;
}
span:has(+ input:disabled),
input:disabled + span,
.deleted output {
  opacity: 0.5;
}
p {
  margin: 2.5rem 1rem;
}
datalist {
  display: none;
}
.hide label.number,
.hide label.checkbox {
  display: none;
}
.hide label.combo,
.hide label.combo + label {
  display: revert;
}
.expand input {
  display: none;
}
.expand .plus,
.expand input:checked ~ .minus {
  display: none;
}
.expand .minus,
.expand input:checked ~ .plus {
  display: block;
  font-size: medium;
  font-weight: bold;
}
.titlebar:has(input:checked) ~ :is(.header, .content, hr) {
  display: none;
}
.max {
  color: var(--color-highlight);
}
dialog {
  margin: revert;
  color: var(--color);
  background-color: var(--bgcolor);
  border: 1px solid var(--color);
  border-radius: 0.5rem;
}
dialog::backdrop {
  background-color: #002a;
}
dialog form {
  padding: 0.5rem 1.5rem;
}
.control {
  text-align: right;
  margin-top: 0.5rem;
}
.control input {
  padding: revert;
  margin-left: 0.5rem;
}
html:has(dialog[open]) {
  overflow: hidden;
}
</style>
<script>
"use strict";

const checkColorPicker = () => {
  const color = document.createElement("input");
  color.type = "color";
  color.value = "invalid";
  return color.type === "color" && color.value !== "invalid";
};

const randomColor = () => {
  const r = () => (0x120 + Math.floor(Math.random() * 0x80)).toString(16).slice(1);
  return `#${r()}${r()}${r()}`;
};

const count = (s) => {
  return [...new Intl.Segmenter().segment(s)].length;
};

class BaseItem {
  setDefaultParams(){
    this.params = new Map(this.constructor.defaultParams);
  }
  get(key){
    if(this.checkSkipFlag(key)) return 0;
    return this.params.get(key);
  }
  getEquip(key){
    if(this.get(key + "装備")){
      const value = Math.floor(this.get(key + "Lv.") / 10);
      return 5 > value ? 0 : value;
    }
    return 0;
  }
  checkSkipFlag(key){
    const flagKey = this.constructor.skipFlagMap.get(key);
    if(flagKey && !this.get(flagKey)) return true;
    return false;
  }
  set(key, value){
    return this.params.set(key, value);
  }
  checkDisabled(){
    return false;
  }
}

class Unit extends BaseItem {
  constructor(name){
    super();
    this.name = name;
    this.setDefaultParams();
  }
  static skipFlagMap = new Map([
    ["SK View", "SKを使用"],
    ["ファン数", "ファン数を使用"],
  ]);
  static defaultParams = new Map([
    ["View", 1500],
    ["SK View", 350],
    ["SKを使用", true],
    ["ファン数", 1000],
    ["ファン数を使用", false],
    ["刻印", 0],
    ["color", ""],
    ["モクダイLv.", 100],
    ["モクダイ装備", false],
    ["コウキLv.", 100],
    ["コウキ装備", false],
    ["ナリヒトLv.", 100],
    ["ボレアリスLv.", 100],
    ["ボレアリス装備", false],
    ["ダンゾーLv.", 100],
    ["ダンゾー装備", false],
    ["メリデLv.", 100],
    ["メリデ装備", false],
    ["ヨハックLv.", 100],
    ["ヨハック装備", false],
    ["ヤスヒコLv.", 100],
  ]);
  static maxValue = new Map([
    ["View", 9999],
    ["SK View", 500],
    ["ファン数", 1000],
    ["刻印", 100],
  ]);
  static suggests = new Map([
    ["SK View", [500, 425, 350, 275, 200]],
  ]);
}

const DISABLE = {
  IF_NOT_UNIT: 1,
  IF_UNIT: 2,
  ALWAYS: 3,
};

class Action extends BaseItem {
  constructor(unit){
    super();
    if(unit instanceof Action){
      this.unit = unit.unit || undefined;
      this.params = new Map(unit.params);
    }else{
      this.unit = unit;
      this.setDefaultParams();
      if(unit) this.params.set("color", unit.params.get("color"));
    }
  }
  get name(){
    return this.unit ? this.unit.name : "";
  }
  checkDisabled(key){
    const flag = this.constructor.disabled.get(key) || 0;
    switch(flag){
      default:
        return false;
      case DISABLE.IF_NOT_UNIT:
        return !this.unit;
      case DISABLE.IF_UNIT:
        return !!this.unit;
      case DISABLE.ALWAYS:
        return true;
    }
  }
  get(key){
    let value;
    if(this.checkSkipFlag(key)) return 0;
    if(this.unit) value = this.unit.get(key);
    return value || this.params.get(key) || 0;
  }
  static skipFlagMap = new Map([
    ["刻印", "刻印を適用"],
  ]);
  static disabled = new Map([
    ["View", DISABLE.IF_UNIT],
    ["補正後View", DISABLE.ALWAYS],
    ["ナリヒト装備", DISABLE.IF_NOT_UNIT],
    ["ウェイト", DISABLE.IF_NOT_UNIT],
    ["刻印を適用", DISABLE.IF_NOT_UNIT],
    ["最終コスト", DISABLE.ALWAYS],
    ["消費後VP", DISABLE.ALWAYS],
    ["ヤスヒコ装備", DISABLE.IF_NOT_UNIT],
  ]);
  static defaultParams = new Map([
    ["View", 1500],
    ["注目", false],
    ["発破/発破+", 0],
    ["ナリヒト装備", false],
    ["補正後View", 0],
    ["ウェイト", false],
    ["color", ""],
    ["消費VP", 0],
    ["刻印を適用", false],
    ["消費減少", 0],
    ["覚醒", false],
    ["消費増加", 0],
    ["過消費", false],
    ["最終コスト", 0],
    ["消費後VP", 0],
    ["VP獲得", 0],
    ["協奏", false],
    ["ヤスヒコ装備", false],
    ["COMBO", 0],
    ["COMBO継続", true],
    ["COMBO加算", 1],
  ]);
  static maxValue = new Map([
    ["View", 9999],
    ["発破/発破+", 1000],
    ["消費VP", 99999],
    ["消費減少", 99999],
    ["消費増加", 99999],
    ["VP獲得", 99999],
    ["COMBO", 99],
    ["COMBO加算", 9],
  ]);
  static suggests = new Map([
    ["発破/発破+", [1000, 500]],
    ["消費減少", [3000, 2000, 1500, 1250, 1000, 500]],
  ]);
}

class BaseManager {
  constructor(id, itemClass){
    const fieldset = document.getElementById(id);
    const div = document.createElement("div");
    const button = document.createElement("input");
    this.counter = document.createElement("output");
    this.container = document.createElement("div");
    this.Item = itemClass;
    this.data = [];
    button.type = "button";
    button.value = "＋";
    button.addEventListener("click", this.createAddButtonHandler());
    div.className = "appendpanel";
    div.append(button);
    div.append(this.counter);
    fieldset.append(this.container);
    fieldset.append(div);
    this.updateCounter();
    fieldset.addEventListener("focusin", this.createFocusinHandler());
    fieldset.addEventListener("focusout", this.createFocusoutHandler());
    this.datalist = new Map();
    if(itemClass.suggests){
      let index = 0;
      for(const [key, value] of itemClass.suggests){
        const id = `${this.constructor.name}-${index++}`;
        this.appendDatalist(fieldset, id, value);
        this.datalist.set(key, id);
      }
    }
    this.autoCollapse = true;
    this.insertAutoCollapse();
  }
  createAddButtonHandler(){
    return () => {
      this.safeAddItem();
    };
  }
  createFocusoutHandler(){
    return (e) => {
      const elem = e.target;
      if(["number", "text"].includes(elem.type) && elem.list){
        if(!elem.value) elem.value = elem.dataset.backup;
        delete elem.dataset.backup;
      }
    };
  }
  createFocusinHandler(){
    return (e) => {
      const elem = e.target;
      if(["number", "text"].includes(elem.type)){
        if(elem.list){
          elem.dataset.backup = elem.value;
          elem.value = "";
        }else{
          setTimeout(function(){
            try{
              elem.setSelectionRange(0, elem.value.length);
            }catch(e){
              elem.select();
            }
          }, 0);
        }
      }
    };
  }
  insertAutoCollapse(){
    const content = document.createElement("div");
    const label = document.createElement("label");
    const input = document.createElement("input");
    content.append(label);
    input.type = "checkbox";
    input.checked = this.autoCollapse;
    input.addEventListener("change", this.createAutoCollapseHandler());
    label.append(input);
    label.append(document.createTextNode("追加時に他を折りたたむ"));
    this.insertPanel(content);
  }
  createAutoCollapseHandler(){
    return (e) => {
      this.autoCollapse = e.target.checked;
    };
  }
  appendDatalist(parent, id, list){
    const datalist = document.createElement("datalist");
    datalist.id = id;
    for(const value of list){
      const option = document.createElement("option");
      option.textContent = value;
      datalist.append(option);
    }
    parent.append(datalist);
  }
  static maxItem = 999;
  updateCounter(){
    this.counter.value = `${this.data.length}/${this.constructor.maxItem}`;
    if(this.data.length >= this.constructor.maxItem){
      this.counter.classList.add("max");
    }else{
      this.counter.classList.remove("max");
    }
  }
  safeAddItem(...args){
    if(this.constructor.maxItem > this.data.length) return this.addItem(...args);
    alert(`これ以上追加できません (${this.data.length}/${this.constructor.maxItem})`);
  }
  addItem(...args){
    const item = new this.Item(...args);
    this.data.push(item);
    if(this.autoCollapse) this.collapseAll();
    this.appendPanel(item);
    this.updateCounter();
    this.update("add", item);
    return item;
  }
  removeItem(item){
    const index = this.data.indexOf(item);
    if(index === -1) return;
    this.data.splice(index, 1);
    this.container.children[index].remove();
    this.updateCounter();
    this.update("remove", item);
    return item;
  }
  moveItem(item){
    const b = this.data.indexOf(item);
    const a = b - 1;
    if(a >= 0){
      const children = this.container.children;
      [this.data[a], this.data[b]] = [this.data[b], this.data[a]];
      children[b].after(children[a]);
      this.update("move");
    }
  }
  setParams(item, key, value){
    item.params.set(key, value);
    this.update("set", item);
  }
  insertPanel(content){
    const div = document.createElement("div");
    div.className = "panel";
    content.className = "content";
    div.append(content);
    this.container.before(div);
  }
  appendPanel(item){
    const div = document.createElement("div");
    const bar = document.createElement("div");
    
    const left = document.createElement("div");
    const right = document.createElement("div");
    const label = document.createElement("label");
    const plus = document.createElement("div");
    const minus = document.createElement("div");
    const checkbox = document.createElement("input");
    const title = document.createElement("output");
    const header = this.createHeader(item);
    const footer = this.createFooter(item);
    let initialColor = item.params.get("color");
    if(!initialColor){
      const color = document.createElement("input");
      const rainbow = document.createElement("label");
      initialColor = randomColor();
      color.type = "color";
      color.value = initialColor;
      color.addEventListener("change", this.createColorChangeHandler(div, item));
      rainbow.className = "colorlabel";
      rainbow.textContent = "🌈";
      rainbow.append(color);
      right.append(rainbow);
      item.params.set("color", initialColor);
    }
    div.style.backgroundColor = initialColor + "40";
    div.className = "panel";
    bar.className = "titlebar";
    this.appendButton(right, "🔼", this.createMoveItemHandler(item)).className = "upbutton";
    this.appendButton(right, "❌", this.createRemoveItemHandler(item));
    if(item.name) title.value = item.name;
    checkbox.type = "checkbox"
    plus.textContent = "[+]";
    minus.textContent = "[-]";
    plus.className = "plus";
    minus.className = "minus";
    label.className = "expand";
    label.append(checkbox);
    label.append(plus);
    label.append(minus);
    left.append(label);
    left.append(title);
    bar.append(left);
    bar.append(right);
    div.append(bar);
    if(header){
      header.className = "header";
      div.append(header);
      this.appendHR(div);
    }
    this.container.append(div);
    this.appendContent(div, item);
    if(footer){
      this.appendHR(div);
      footer.className = "footer";
      div.append(footer);
    }
  }
  createColorChangeHandler(div, item){
    return (e) => {
      const color = e.target.value;
      div.style.backgroundColor = color + "40";
      this.setParams(item, "color", color);
    };
  }
  createMoveItemHandler(item){
    return () => {
      this.moveItem(item);
    };
  }
  createRemoveItemHandler(item){
    return () => {
      this.removeItem(item);
    };
  }
  appendButton(parent, label, onclick){
    const button = document.createElement("button");
    button.type = "button";
    button.textContent = label;
    button.addEventListener("click", onclick);
    parent.append(button);
    return button;
  }
  appendContent(parent, item){
    const content = document.createElement("div");
    const gridA = document.createElement("div");
    const gridB = document.createElement("div");
    let current = gridA;
    gridA.className = "grid";
    gridB.className = "grid";
    content.className = "content";
    content.append(gridA);
    this.appendHR(content);
    content.append(gridB);
    parent.append(content);
    for(const [key, value] of item.params){
      if(key === "color"){
        current = gridB;
      }else{
        this.appendInput(current, item, key, value);
      }
    }
  }
  appendHR(parent){
    parent.append(document.createElement("hr"));
  }
  static classNameTable = new Map();
  appendInput(parent, item, key, value){
    const label = document.createElement("label");
    const input = document.createElement("input");
    const text = document.createElement("span");
    const list = this.datalist.get(key);
    const className = this.constructor.classNameTable.get(key);
    text.textContent = key;
    label.append(input);
    input.disabled = item.checkDisabled(key);
    switch(typeof value){
      case "number":
        if(input.disabled) value = 0;
        label.prepend(text);
        label.classList.add("number");
        input.type = "number";
        input.value = value;
        input.min = 0;
        if(key.endsWith("Lv.")){
          input.max = 100;
          input.classList.add("lv");
        }else{
          input.max = this.Item.maxValue.get(key);
        }
        input.addEventListener("change", this.createNumberChangeHandler(item, key));
        break;
      case "boolean":
        if(input.disabled) value = false;
        label.append(text);
        label.classList.add("checkbox");
        input.type = "checkbox";
        input.checked = value;
        input.addEventListener("change", this.createCheckboxChangeHandler(item, key));
        break;
    }
    if(className) label.classList.add(className);
    parent.append(label);
    if(list) input.setAttribute("list", list);
  }
  createNumberChangeHandler(item, key){
    return (e) => {
      const value = Math.min(e.target.max, Math.max(0, e.target.value | 0));
      e.target.value = value;
      this.setParams(item, key, value);
    };
  }
  createCheckboxChangeHandler(item, key){
    return (e) => {
      this.setParams(item, key, e.target.checked);
    };
  }
  createHeader(){

  }
  createFooter(){

  }
  update(type, item){

  }
  collapseAll(){
    for(const checkbox of this.container.querySelectorAll(".expand input")) checkbox.checked = true;
  }
}

class AddUnitDialog{
  constructor(){
    const dialog = document.createElement("dialog");
    const form = document.createElement("form");
    const title = document.createElement("div");
    const tab = document.createElement("div");
    const control = document.createElement("div");
    const label = document.createElement("label");
    const input = document.createElement("input");
    const ok = document.createElement("input");
    const cancel = document.createElement("input");
    this.names = new Set();
    form.method = "dialog";
    title.textContent = "キャラを追加";
    title.className = "titlebar";
    input.type = "text";
    input.autofocus = true;
    label.append("名前：", input);
    tab.className = "tab";
    tab.append(label);
    ok.type = "submit";
    ok.value = "OK";
    cancel.type = "button";
    cancel.value = "Cancel";
    control.className = "control";
    control.append(cancel, ok);
    form.append(tab, control);
    dialog.append(title, form);
    document.body.append(dialog);
    cancel.addEventListener("click", this.createCancelHandler(dialog));
    dialog.addEventListener("close", this.createCloseHandler(dialog));
    dialog.addEventListener("click", this.createBackdropHandler(dialog));
    input.addEventListener("change", this.createNameValidator(input));
    this.form = form;
    this.dialogElement = dialog;
  }
  createCancelHandler(dialog){
    return () => {
      dialog.close();
    };
  }
  createCloseHandler(dialog){
    return () => {
      if(dialog.returnValue === "OK"){
        const value = this.form.querySelector(".tab input").value;
        this.addName(value);
        this.resolve(value);
      }else{
        this.resolve(null);
      }
      delete this.promise;
      delete this.resolve;
    };
  }
  createBackdropHandler(dialog){
    return (e) => {
      if(!e.target.closest("form")) dialog.close();
    };
  }
  createNameValidator(input){
    const validator = (e) => {
      const value = input.value;
      let message = "";
      if(!e || input.offsetHeight){
        if(!value){
          message = "名前を入力してください";
        }else if(count(value) > 10){
          message = "名前は10文字以内にしてください";
        }else if(this.names.has(value)){
          message = "既に存在する名前です";
        }
      }
      input.setCustomValidity(message);
    };
    validator();
    return validator;
  }
  showModal(){
    if(this.promise){
      return this.promise;
    }else{
      this.form.reset();
      this.promise = new Promise(resolve => {
        this.resolve = resolve;
      });
      this.dialogElement.showModal();
      return this.promise;
    }
  }
  addName(name){
    this.names.add(name);
  }
  deleteName(name){
    this.names.delete(name);
  }
}

class UnitManager extends BaseManager{
  constructor(id, timeline){
    super(id, Unit);
    this.timeline = timeline;
    this.autoAdd = true;
    this.insertConfigPanel();
    this.dialog = new AddUnitDialog();
  }
  insertConfigPanel(){
    const content = document.createElement("div");
    const label = document.createElement("label");
    const input = document.createElement("input");
    content.append(label);
    input.type = "checkbox";
    input.checked = this.autoAdd;
    input.addEventListener("change", this.createConfigPanelHandler());
    label.append(input);
    label.append(document.createTextNode("タイムラインに自動追加"));
    this.insertPanel(content);
  }
  createConfigPanelHandler(){
    return (e) => {
      this.autoAdd = e.target.checked;
    };
  }
  static maxItem = 10;
  async addItem(){
    const name = await this.dialog.showModal();
    if(name){
      const item = super.addItem(name);
      if(this.autoAdd) this.timeline.addItem(item);
    }
  }
  removeItem(item){
    this.dialog.deleteName(item.name);
    super.removeItem(item);
  }
  createFooter(item){
    const footer = document.createElement("div");
    const button = document.createElement("input");
    button.type = "button";
    button.value = "タイムラインに追加";
    button.addEventListener("click", this.createAddTimelineButtonHandler(item));
    footer.append(button);
    return footer;
  }
  createAddTimelineButtonHandler(item){
    return () => {
      this.timeline.safeAddItem(item);
    };
  }
  update(type, item){
    switch(type){
      case "add":
      case "move":
        break;
      case "remove":
      case "set":
        this.timeline.update(`${type}-unit`, item);
    }
  }
}

class TimelineManager extends BaseManager{
  constructor(id){
    super(id, Action);
    this.insertInitialVP();
    this.initialVP = 1;
  }
  insertInitialVP(){
    const content = document.createElement("div");
    const label = document.createElement("label");
    const input = document.createElement("input");
    content.append(label);
    label.textContent = "ViewPower";
    input.type = "number";
    input.min = 1;
    input.max = 999999;
    input.value = 1;
    input.addEventListener("change", this.createInitialVPHandler());
    label.append(input);
    this.insertPanel(content);
  }
  createInitialVPHandler(){
    return (e) => {
      const value = Math.min(e.target.max, Math.max(0, e.target.value | 0));
      e.target.value = value;
      this.initialVP = value;
      this.update();
    };
  }
  createHeader(){
    const header = document.createElement("div");
    const output = document.createElement("output");
    output.textContent = "ViewPower 0";
    header.append(output);
    return header;
  }
  createFooter(item){
    const footer = document.createElement("div");
    const div = document.createElement("div");
    const button = document.createElement("input");
    const output = document.createElement("output");
    button.type = "button";
    button.value = "複製";
    button.addEventListener("click", this.createCloneButtonHandler(item));
    output.textContent = "ViewPower 0";
    div.append(button);
    footer.append(div);
    footer.append(output);
    return footer;
  }
  createCloneButtonHandler(item){
    return () => {
      this.safeAddItem(item);
    };
  }
  static classNameTable = new Map([
    ["View", "view"],
    ["補正後View", "modview"],
    ["COMBO", "combo"],
    ["最終コスト", "cost"],
    ["消費後VP", "spend"],
  ]);
  calc(item, currentVP, comboCount, block){
    let view = item.get("View");
    let gain = item.get("VP獲得");
    let combo = this.combo(comboCount);
    let cost = item.get("消費VP");
    const seal = item.get("刻印");
    const viewUp = 100 + item.getEquip("モクダイ") + item.getEquip("コウキ") + item.getEquip("ナリヒト") * 2;
    const gainUp = 100 + item.getEquip("ボレアリス") + item.getEquip("ダンゾー");
    const meride = item.getEquip("メリデ") * 25;
    const yohack = item.getEquip("ヨハック") * 30;
    const yasuhiko = item.getEquip("ヤスヒコ") * 40;
    const color = item.get("color");
    const comboInput = block.querySelector(".combo input");
    if(item.get("COMBO継続")){
      comboInput.value = comboCount;
      item.params.set("COMBO", comboCount);
      comboInput.disabled = true;
    }else{
      comboCount = item.get("COMBO");
      comboInput.disabled = false;
    }
    block.style.backgroundColor = color + "40";
    view += item.get("SK View");
    view = Math.floor(view * viewUp / 100);
    if(item.unit) block.querySelector(".view input").value = view;
    if(item.get("注目")) view = Math.floor(view * 15 / 10);
    view += item.get("ファン数");
    view += item.get("発破/発破+");
    block.querySelector(".modview input").value = view;
    if(0 > currentVP){
      block.querySelector(".header output").value = "\u2937 VPが足りません";
    }else{
      if(meride) currentVP += Math.floor(view * combo * meride / 10000);
      block.querySelector(".header output").value = `\u2937 ViewPower ${currentVP}`;
    }
    if(item.get("ウェイト")){
      block.querySelectorAll(".grid")[1].classList.add("hide");
      block.querySelector(".footer output").value = `\u2937 ViewPower ${currentVP}`;
      return [currentVP, comboCount];
    }else{
      block.querySelectorAll(".grid")[1].classList.remove("hide");
    }
    if(seal) cost = Math.floor(cost * (1000 - seal * 2) / 1000);
    if(item.get("過消費")) cost *= 2;
    if(item.get("覚醒")) cost = Math.floor(cost / 2);
    cost = Math.max(0, cost + item.get("消費増加") - item.get("消費減少"));
    block.querySelector(".cost input").value = cost;
    if(cost > currentVP){
      block.querySelector(".footer output").value = "\u2937 VPが足りません";
      return [-1, 0];
    }
    currentVP -= cost;
    block.querySelector(".spend input").value = currentVP;
    gain = Math.floor(gain * gainUp / 100);
    if(item.get("協奏")) gain = Math.floor(gain * 15 / 10);
    currentVP += Math.floor(gain * combo / 10);
    currentVP += Math.floor(view * combo / 10);
    comboCount += item.get("COMBO加算");
    combo = this.combo(comboCount);
    if(yohack) currentVP += Math.floor(Math.floor(view * yohack / 1000) * combo / 10);
    if(yasuhiko) currentVP += Math.floor(Math.floor(view * yasuhiko / 1000) * combo / 10);
    block.querySelector(".footer output").value = `\u2937 ViewPower ${currentVP}`;
    return [currentVP, comboCount];
  }
  combo(n){
    if(!n) return 10;
    return Math.min(15, n + 9);
  }
  update(type, item){
    const block = this.container.querySelectorAll(".panel");
    let vp = this.initialVP;
    let cc = 0;
    let n = 0;
    for(const data of this.data){
      if(type === "remove-unit" && data.unit === item){
        data.unit = 0;
        block[n].classList.add("deleted");
        block[n].querySelector(".titlebar output").value = "削除済";
        block[n].querySelector(".header output").value = block[n].querySelector(".footer output").value = "\u2937 ViewPower -";
        for(const input of block[n].querySelectorAll(".content input, .footer input")) input.disabled = true;
      }else if(data.unit !== 0){
        [vp, cc] = this.calc(data, vp, cc, block[n]);
      }
      n++;
    }
  }
}

document.addEventListener("DOMContentLoaded", () => {
  const tm = new TimelineManager("timeline");
  const um = new UnitManager("unit", tm);
  if(checkColorPicker()) document.documentElement.classList.add("hidecolor");
});
</script>
<title>LAH VPシミュレータ（β）</title>
<form>
  <fieldset id=unit>
    <legend>キャラ</legend>
  </fieldset>
  <fieldset id=timeline>
    <legend>タイムライン</legend>
  </fieldset>
</form>
<p>
  <a href="/">戻る</a>
</p>
